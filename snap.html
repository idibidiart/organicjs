<!DOCTYPE html>
<html lang="en" itemscope itemtype="http://schema.org/WebPage">
<title itemprop="name">SVG Bouncing Ball Animation</title>
<span hidden itemprop="author">Marc Fawzi</span>
<span hidden itemprop="dateCreated">Feb 21, 2013</span>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <!-- liquid layout -->
    <link href="css/snap.css" rel="stylesheet" type="text/css" />
    <link href="css/organic.css" rel="stylesheet" type="text/css" />
    <!-- Note --

        This app uses "OrganicJS"

        OrganicJS supports reusable components with chain*able properties and public methods, dynamic setters/getters,
        HTML/SVG template support, and a contextual component cache (for sharing data/behavior among components in a
        decoupled, soft manner)

        The main file is organic.js. However, the component pattern is partly implemented in the app file (bouncy.js)

    -->
</head>
<body>

<!-- id's are replaced with d's to avoid polluting JS window namespace -->

<div template d="widget1">    <!--- first template -->
    <input type="range" d="slider"/>
    <div d='svgWrapper'>
        <svg d='svgBox' xmlns="http://www.w3.org/2000/svg"
             preserveAspectRatio="xMinYMin meet" viewbox='0 0 1280 960'>
            <!-- board -->
            <rect d="board" />
            <!-- ball -->
            <circle template d="ball" />  <!--- second nested template  -->
        </svg>
    </div>
</div>

</body>

<!-- Self-authored micro-framework -->
<script src="js/organic.js"></script>
<!-- jQuery 1.8.3 -->
<script src="js/jquery.min.js"></script>
<!-- Bouncing ball app incl. component pattern -->
<script src="js/bouncy.js"></script>

<script>

    // Notes
    //
    // The in-line script shows how to render templates and how to
    // access each component's public properties and methods
    //
    // Hooking up application level unit tests would make a nice extension
    // to this example

    (function() {

        //see organic.js
        var cache = app.cache();

        var model = app.model()

        // rendering templates starts from inner most template (depth first, post order)

        // save original source of widget1  (need only be called once)
        app.save($('[d="widget1"]'))

        // render instance 1 of ball in-place, using the nested template for ball
        app.render($('[d="widget1"] [d="ball"]'), 1)

        // render instance 2 of ball in-place, using the nested template for ball
        app.render($('[d="widget1"] [d="ball"]'), 2)

        // render instance 1 of widget1 in-place, using the template for widget1
        app.render($('[d="widget1"]'), 1)

        // restore original source of widget1 so it may be reused
        app.restore($('[d="widget1"]'))

        var board1 = app.board(cache, model)
                // cache context
                .widget('widget_1')
                // data model scope
                .scope('model_1')
                //settings
                .elem($('[d="widget1-instance-1"] [d="board"]'))
                .top(100)
                .left(100)
                .width(500)
                .height(500)
                .fill("lightgray")
                // save component to cache, using "widget context/component name" (i.e. widget_1/board) as path
                .provide('board')
                //draw
                .draw();

        var ball1 = app.ball(cache, model)
                // widget context
                .widget('widget_1')
                // data model scope
                .scope('model_1')
                // consume soft dependencies from cache into specific methods or properties
                .consume([{name: 'board', into: 'animate'}])
                // settings
                .elem($('[d="widget1-instance-1"] [d="ball-instance-1"]'))
                .radius(10)
                .dx(2)
                .dy(4)
                //
                // Feature: can use a value-producing closure (a function that returns a function
                // that returns a value) as an argument instead of a regular value-producing
                // function so as have the inner function generate the value dynamically
                // every time the property is read (dynamic properties are very useful)
                //
                // Feature: "this" in functions and closures refers to the component instance
                //
                .x(function() {
                   return board1.left() + (board1.width() / 2)
                })
                .y(function() {
                   return  board1.top() + (board1.height() / 2)
                })
                .fill("red")
                // draw
                .draw();

        var ball2 = app.ball(cache, model)
                // widget context
                .widget('widget_1')
                // data model scope
                .scope('model_1')
                // consume soft dependencies from cache into specific methods or properties
                .consume([{name: 'board', into: 'animate'}])
                // settings
                .elem($('[d="widget1-instance-1"] [d="ball-instance-2"]'))
                .radius(ball1.radius() * 2)
                .dx(6)
                .dy(12)
                //
                // Feature: can use a value-producing closure (a function that returns a function
                // that returns a value) as an argument instead of a regular value-producing
                // function so as have the inner function generate the value dynamically
                // every time the property is read (dynamic properties are very useful)
                //
                // Feature: "this" in functions and closures refers to the component instance
                //
                .x(function() {
                    return board1.left() + (board1.width() / 3)
                })
                .y(function() {
                    return  board1.top() + (board1.height() / 2)
                })
                .fill("blue")
                // draw
                .draw();

        $('[d="widget1-instance-1"] [d="board"]').bind("click", function() {

            if (!ball1.animating()) {
               ball1.animate()
               ball2.animate()
            } else {
               // ball1.kick()
            }
        })


        var slider1 = app.slider(cache, model)
                // cache context
                .widget('widget1')
                // data model scope
                .scope('model1')
                //settings
                .elem($('[d="widget1-instance-1"] [d="slider"]'))
                // need to understand viewBox better w/r/t positioning, couple magic ratios follow
                .left("7%")
                .top("1%")
                .min("10")
                .max("50")
                .value("10")
                // method that takes a function and $.binds it to the slider's 'change' event
                .onChange(function() { ball1.resize(this.value); ball2.resize(this.value * 2)})
                //setup
                .init();


    } ())
</script>
</html>

