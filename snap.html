<!DOCTYPE html>
<html lang="en" itemscope itemtype="http://schema.org/WebPage">
<title itemprop="name">SVG Bouncing Ball Animation</title>
<span hidden itemprop="author">Marc Fawzi</span>
<span hidden itemprop="dateCreated">Feb 21, 2013</span>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <!-- liquid layout -->
    <link href="css/snap.css" rel="stylesheet" type="text/css" />
    <!-- Note --

        This app uses "OrganicJS"

        OrganicJS supports reusable components with chain*able properties and public methods, dynamic setters/getters,
        HTML/SVG template support, and a contextual component cache (for sharing data/behavior among components in a
        decoupled, soft manner)

        The main file is organic.js. However, the component pattern is partly implemented in the app file (bouncy.js)

    -->
</head>
<body>

<div hidden class='widget1-template'>
<input type="range" class="slider"/>
    <div class='svgWrapper'>
        <svg class='svgBox' xmlns="http://www.w3.org/2000/svg"
             preserveAspectRatio="xMinYMin meet" viewbox='0 0 1280 960'>
            <!-- board -->
            <rect class="board" />
            <!-- ball -->
            <circle hidden class="ball-template" />
        </svg>
    </div>
</div>

</body>

<!-- Self-authored micro-framework -->
<script src="js/organic.js"></script>
<!-- jQuery 1.8.3 -->
<script src="js/jquery.min.js"></script>
<!-- Bouncing ball app incl. component pattern -->
<script src="js/bouncy.js"></script>

<script>

    // Notes
    //
    // This in-line script does *NOT* go against testability
    //
    // It serves as an example of how to access each component's public
    // properties and methods
    //
    // Hooking up *dynamic* unit tests with JSCheck could make a nice
    // extension to this exercise...

    (function() {

        //see organic.js
        var cache = app.cache();

        var model = app.model()

        // rendering templates starts from most inner template

        // render the first instance of ball using the template for ball
        app.render($('.ball-template'), "ball-instance1")

        // render the second instance of ball using the template for ball
        app.render($('.ball-template'), "ball-instance2")

        // render first instance of widget1 using the template for widget1
        app.render($('.widget1-template'), "widget1-instance1")

        console.log($('.ball-instance1'))

        var board1 = app.board(cache, model)
                // cache context
                .widget('widget_1')
                // data model scope
                .scope('model_1')
                //settings
                .elem($('.widget1-instance1 .board'))
                .top(100)
                .left(100)
                .width(500)
                .height(500)
                .fill("lightgray")
                // save component to cache, using "widget context/component name" (i.e. widget_1/board) as path
                .provide('board')
                //draw
                .draw();

        var ball1 = app.ball(cache, model)
                // widget context
                .widget('widget_1')
                // data model scope
                .scope('model_1')
                // consume soft dependencies from cache into specific methods or properties
                .consume([{name: 'board', into: 'animate'}])
                // settings
                .elem($('.widget1-instance1 .ball-instance1'))
                .radius(10)
                .dx(2)
                .dy(4)
                //
                // Feature: can use a value-producing closure (a function that returns a function
                // that returns a value) as an argument instead of a regular value-producing
                // function so as have the inner function generate the value dynamically
                // every time the property is read (dynamic properties are very useful)
                //
                // Feature: "this" in functions and closures refers to the component instance
                //
                .x(function() {
                   return board1.left() + (board1.width() / 2)
                })
                .y(function() {
                   return  board1.top() + (board1.height() / 2)
                })
                .fill("red")
                // draw
                .draw();

        var ball2 = app.ball(cache, model)
                // widget context
                .widget('widget_1')
                // data model scope
                .scope('model_1')
                // consume soft dependencies from cache into specific methods or properties
                .consume([{name: 'board', into: 'animate'}])
                // settings
                .elem($('.widget1-instance1 .ball-instance2'))
                .radius(ball1.radius() * 2)
                .dx(6)
                .dy(12)
                //
                // Feature: can use a value-producing closure (a function that returns a function
                // that returns a value) as an argument instead of a regular value-producing
                // function so as have the inner function generate the value dynamically
                // every time the property is read (dynamic properties are very useful)
                //
                // Feature: "this" in functions and closures refers to the component instance
                //
                .x(function() {
                    return board1.left() + (board1.width() / 3)
                })
                .y(function() {
                    return  board1.top() + (board1.height() / 2)
                })
                .fill("blue")
                // draw
                .draw();

        $('.widget1-instance1 .board').bind("click", function() {

            if (!ball1.animating()) {
               ball1.animate()
               ball2.animate()
            } else {
               // ball1.kick()
            }
        })


        var slider1 = app.slider(cache, model)
                // cache context
                .widget('widget1')
                // data model scope
                .scope('model1')
                //settings
                .elem($('.widget1-instance1 .slider'))
                // need to understand viewBox better w/r/t positioning, couple magic ratios follow
                .left("7%")
                .top("1%")
                .min("10")
                .max("50")
                .value("10")
                // method that takes a function and $.binds it to the slider's 'change' event
                .onChange(function() { ball1.resize(this.value); ball2.resize(this.value * 2)})
                //setup
                .init();


    } ())
</script>
</html>

